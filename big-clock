#!/usr/bin/env python
# Copyright (c) 2016-2018 Jeffrey Hutzelman.
# All Rights Reserved.
# See LICENSE for licensing terms.

import Tkinter as tk
from idlelib.WidgetRedirector import WidgetRedirector
import ScrolledText
import UserDict
import BaseHTTPServer
import SimpleHTTPServer
from SocketServer import ThreadingMixIn
import socket, ssl
import zeroconf
import struct
import hashlib
import threading
import Queue
import codecs
import base64
import array
import time
import json
import os
import sys
import signal
import csv
import argparse
from traceback import format_exc as format

server_version = '1.2'

config_int = { 'http_port', 'https_port', 'rmon_port', 'rmrelay_port',
        'data_port', 'console_port', 'monitor_port' }
config_hide = { 'gui' }

ssl_mode = False
maxMessageLen = 1024
watchdogTimeout = 5
wsPingPeriod = 5
wsMaxPings = 3
have_syslog = False
gui_app = None
ReExec = False

try:
    import fcntl
    def cloexec(sock):
        flags = fcntl.fcntl(sock.fileno(), fcntl.F_GETFD)
        flags |= fcntl.FD_CLOEXEC
        fcntl.fcntl(sock.fileno(), fcntl.F_SETFD, flags)
except ImportError:
    def cloexec(sock):
        pass
try:
    import syslog
    have_syslog = True
except ImportError:
    pass


class TkConfigVars(UserDict.DictMixin):
    def __init__(self,data,intkeys={}):
        self.data = {}
        for (k,v) in data.items():
            if k in intkeys: self.data[k] = tk.IntVar()
            else:            self.data[k] = tk.StringVar()
            self.data[k].set(v)
    def __getitem__(self,key):     return self.data[key].get()
    def __setitem__(self,key,val): self.data[key].set(val)
    def __contains__(self,item):   return item in self.data
    def keys(self):                return self.data.keys()
    def __iter__(self):            return self.data.iterkeys()
    def var(self,key):             return self.data[key]

def parse_args():
    global config
    parser = argparse.ArgumentParser()
    parser.add_argument('--gui',    action='store_const', const=True,
            help='Enable GUI console (default)')
    parser.add_argument('--no-gui', action='store_const', const=False, dest='gui',
            help='Disable GUI console')
    parser.add_argument('--http-port',      type=int, metavar='PORT', default=8000,
            help='port for web server')
    parser.add_argument('--https-port',      type=int, metavar='PORT', default=8443,
            help='port for SSL web server')
    parser.add_argument('--data-port',      type=int, metavar='PORT', default=9999,
            help='port for data feed')
    parser.add_argument('--monitor-port',   type=int, metavar='PORT', default=9988,
            help='port for monitor connections')
    parser.add_argument('--console-port',   type=int, metavar='PORT', default=9977,
            help='port for console connections')
    parser.add_argument('--rmrelay-port',   type=int, metavar='PORT', default=9966,
            help='port for rmonitor relay connections')
    parser.add_argument('--cert-file', help='SSL certificate file')
    parser.add_argument('--key-file', help='SSL key file')
    if have_syslog:
        parser.add_argument('--syslog', action='store_const', const=True,
                help='Send logs to syslog')
    parser.add_argument('--timezone',       default='America/New_York',
            help='timezone for clock display')
    parser.add_argument('--version', action='version', version=server_version)
    parser.add_argument('rmon_server', metavar='rmon-server', nargs='?',
            help='rmonitor server name/address', default='127.0.0.1')
    parser.add_argument('rmon_port',   metavar='rmon-port', nargs='?', type=int,
            help='rmonitor server port', default=50000)
    config = vars(parser.parse_args())
    if config['gui'] == None: config['gui'] = True
    if not have_syslog: config['syslog'] = False
    if config['syslog']:
        syslog.openlog()
    if ((config['cert_file'] and not config['key_file']) 
      or (config['key_file'] and not config['cert_file'])):
        raise Exception('--cert-file and --key-file must be used together')
    if config['cert_file']:
        global ssl_mode
        ssl_mode = True

def log(peer, msg):
    global config
    when = time.strftime('%b %d %H:%M:%S')
    if peer != None:
        msg = peer + ' ' + msg
    if gui_app:
        gui_app.log(when + ' ' + msg)
    elif config['syslog']:
        syslog.syslog(msg)
    else:
        sys.stdout.write(when + ' ' + msg + '\n')

ZC_SERVICES_TYPE = '_services._dns-sd._udp.local.'
class AddressMapper(object):
    def __init__(self, ws=None):
        self.addr_map = { '127.0.0.1' : 'localhost' }
        self.services = {}
        self.queue = Queue.Queue()
        self.ws = ws
        zc = zeroconf.Zeroconf()
        self.svc_browser = zeroconf.ServiceBrowser(
            zc, ZC_SERVICES_TYPE, listener=self)
        self.dns_thr = threading.Thread(target=self.process_queue)
        self.dns_thr.name = 'DNS Lookup Queue'
        self.dns_thr.daemon = True
        self.dns_thr.start()

    def lookup(self, client):
        client['name'] = self.addr_map.get(client['address'], None)
        if client['name'] == None:
            self.queue.put(client)
    def remove_service(self, zc, type_, name): pass
    def add_service(self, zc, type_, name):
        if type_ == ZC_SERVICES_TYPE:
            log(None, "ZC add service: %s" % name)
            if name in self.services: return
            try:
                self.services[type_] = zeroconf.ServiceBrowser(
                    zc, name, listener=self)
            except zeroconf.BadTypeInNameException: pass
        else:
            info = zc.get_service_info(type_, name)
            if len(info.address) == 4:
                addr_str = socket.inet_ntoa(info.address)
                shortname = info.get_name()
                log(None, "ZC add mapping: %s -> %s" % (addr_str, shortname))
                self.addr_map[addr_str] = shortname
                self.ws.addr_map(addr_str, shortname)

    def process_queue(self):
        while True:
            client = self.queue.get(True)
            if client['name'] != None: continue
            try:
                info = socket.gethostbyaddr(client['address'])
                shortname = info[0].split('.')[0]
                client['name'] = shortname
            except: pass

class MyHTTPRequestHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):
    protocol_version = "HTTP/1.0"

    def setup(self):
        self.timeout = 15
        SimpleHTTPServer.SimpleHTTPRequestHandler.setup(self)

    def send_head(self):
        #log("%s:%d" % self.client_address, "send_head %s" % self.path)
        if self.path == "/":
            self.send_response(301)
            self.send_header("Location", "/big-clock.html")
            # avoid sending our cache control headers for this redirect
            SimpleHTTPServer.SimpleHTTPRequestHandler.end_headers(self)
            return None
        return SimpleHTTPServer.SimpleHTTPRequestHandler.send_head(self)


    def end_headers(self):
        self.send_my_headers()
        SimpleHTTPServer.SimpleHTTPRequestHandler.end_headers(self)

    def send_my_headers(self):
        self.send_header("Pragma", "no-cache")
        self.send_header("Expires", "Thu, 01 Dec 1994 16:00:00 GMT")
        self.send_header("Max-Age", "0")
        self.send_header("Set-Cookie", "bigclock_port=%d; max-age: 1" %
                config['data_port'])
        if ssl_mode:
            self.send_header("Set-Cookie", "bigclock_ssl=true; max-age: 1")
        self.send_header("Cache-Control", "no-cache")
        self.send_header("Cache-Control", "must-revalidate")

    def list_directory(self, path):
        self.send_error(404, "No permission to list directory")
        return None

    def copyfile(self, source, outputfile):
        name = source.name[ source.name.replace('\\','/').rfind('/')+1 : ]
        if not name.startswith('big-clock.'):
            return SimpleHTTPServer.SimpleHTTPRequestHandler.copyfile(
                    self, source, outputfile)
        s = os.fstat(source.fileno())
        stamp = time.strftime('%y%m%d-%H%M%S', time.localtime(s.st_mtime))
        outputfile.write(source.read().replace('@@@@@@-@@@@@@',stamp))

class MyHTTPServer(ThreadingMixIn, BaseHTTPServer.HTTPServer):
    def __init__(self, *args, **kwargs):
        self.daemon_threads = True
        BaseHTTPServer.HTTPServer.__init__(self, *args, **kwargs)
        cloexec(self.socket)


class TCPAcceptServer(object):
    def __init__(self, cfg_key, clientType):
        self.cfg_key = cfg_key
        self.ctype = clientType
        self.SERVER_ACTIVE = True
        self.shutdown_complete = threading.Event()

    def _setupSocket(self, port):
        s = socket.socket()
        cloexec(s)
        s.settimeout(5)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind(('', port))
        s.listen(10)
        return s

    def _bindClient(self):
        port = config[self.cfg_key]
        self.socket = self._setupSocket(port)
        log(None, '%s listening on port %d' % (self.ctype, port))
        while self.SERVER_ACTIVE:
            if port != config[self.cfg_key]:
                newport = config[self.cfg_key]
                try:
                    newsock = self._setupSocket(newport)
                    try: self.socket.close()
                    except: pass
                    self.socket = newsock
                    port = newport
                    log(None, '%s listening on port %d' % (self.ctype, port))
                except IOError, e:
                    log(None, '%s _setupSocket: %s' % (self.ctype, e.args[0]))
            try:
                conn, addr = self.socket.accept()
            except Exception, e:
                err = e.args[0]
                if err == 'timed out':
                    continue
                if self.SERVER_ACTIVE:
                    # ignore socket errors if we're shutting down
                    print(format())
                    print(e)
                    self.SERVER_ACTIVE = False
                    return
                else:
                    break
            peer = '%s:%d' % addr
            log(peer, '%s client connected' % self.ctype)
            try:
                cloexec(conn)
                conn.settimeout(5)
            except Exception, e:
                conn.close()
                log(peer, str(type(e)))
                print(format())
                print(e)
            self.handleClient(conn, addr)
        log(None, 'Shutting down %s server port: %s' % (self.ctype, port))
        self.shutdown_complete.set()
        return

    def handleClient(self, conn, addr):
        pass

    def startServer(self):
        server_thr = threading.Thread(target=self._bindClient)
        server_thr.name = '%s Listener' % self.ctype
        server_thr.daemon = True
        server_thr.start()

    def close(self):
        self.SERVER_ACTIVE = False
        if self.socket:
            self.socket.close()

    def wait(self):
        try:
            while not self.shutdown_complete.wait(0.5): pass
        except KeyboardInterrupt:
            pass


class TCPUserServer(TCPAcceptServer):
    def __init__(self, cfg_key, clientType, ws):
        TCPAcceptServer.__init__(self, cfg_key, clientType)
        self.ws = ws

    def handleClient(self, conn, addr):
        self.ws.addClient(conn, addr, self.ctype)

# WebSocket server code adapted from
# https://gist.github.com/sadatanwar/222d4643c25f72293461

class WSProtocolError(Exception): pass
class WSHandshakeError(WSProtocolError): pass

GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"

def create_hash(key):
    reply = key + GUID
    sh1 = hashlib.sha1(reply)
    return sh1.digest()

def parse_headers(data, headers):
    lines = data.splitlines()
    for l in lines:
        if l == '':
            headers[None] = True
            return
        if '' not in headers:
            headers[''] = l.split()
            continue
        parts = l.split(": ", 1)
        if len(parts) == 2:
            headers[parts[0]] = parts[1]

# Conduct handshake.  Possible return values:
#   - 'WS'       WebSocket client
#   - 'CONSOLE'  console client (accepts console commands)
#   - 'MONITOR'  monitor client (read-only)
def handshake(conn, peer):
    log(peer, 'Starting handshake')
    headers = {}
    while None not in headers:
        data = conn.recv(1024)
        if not data: raise EOFError
        parse_headers(data, headers)

    if 'Sec-WebSocket-Key' not in headers:
        raise(WSHandshakeError('missing Sec-WebSocket-Key'))
    digest = create_hash(
        headers['Sec-WebSocket-Key']
    )
    encoded_data = base64.b64encode(digest)
    shake = "HTTP/1.1 101 Web Socket Protocol Handshake\r\n"
    shake += "Upgrade: WebSocket\r\n"
    shake += "Connection: Upgrade\r\n"
    shake += "Sec-WebSocket-Accept: %s\r\n\r\n" % encoded_data
    conn.send(shake)
    log(peer, 'WebSocket handshake successful')
    return 'WS'


class WebSocketServer(object):
    def __init__(self):
        self.clients = {}
        self.SERVER_ACTIVE = True
        self.POLLER_ACTIVE = False
        self.WATCHDOG_ACTIVE = False
        self.lock = threading.Lock()
        self.new_client_data = {}

    def _initClient(self,client):
        self.sendJSON([':V', server_version], clients=[client])
        self.sendJSON([':TZ', config['timezone']], clients=[client])
        for item in sorted(self.new_client_data.items()):
            self.sendJSON(item[1], clients=[client])

    def addr_map(self, addr, name):
        for c in filter(lambda x: x['address'] == addr, self.clients.values()):
            c['name'] = name
            if gui_app: gui_app.update_client_name(c)

    def addClient(self, conn, addr, clientType):
        peer = '%s:%d' % addr
        try:
            clientCode = conn.__hash__()
            client = {
                    'id': clientCode,
                    'address': addr[0],
                    'port': addr[1],
                    'peer': peer,
                    'name': None,
                    'conn': conn,
                    'type': clientType,
                    'squelch': False,
                    'alive': True,
                    'last_pong': time.time(),
                    'user_agent'   : '???',
                    'version_html' : '???',
                    'version_css'  : '???',
                    'version_js'   : '???',
                    'options'      : '-',
                    }
            addrmapper.lookup(client)
            with self.lock:
                self._initClient(client)
                self.clients[clientCode] = client
                if gui_app: gui_app.add_client(client)
                conn = None
                if clientType == 'WS':
                    client_thr = threading.Thread(target=self._wsClient,
                            args=(client,))
                    client_thr.name = 'client ' + peer
                    client_thr.daemon = True
                    client_thr.start()
                if clientType == 'CONSOLE':
                    client['squelch'] = True
                    if gui_app: gui_app.update_client_sql(client)
                    client_thr = threading.Thread(target=self._consClient,
                            args=(client,))
                    client_thr.name = 'client ' + peer
                    client_thr.daemon = True
                    client_thr.start()
                if not self.POLLER_ACTIVE:
                    self.POLLER_ACTIVE = True
                    poller_thr = threading.Thread(target=self._poll)
                    poller_thr.name = 'poller'
                    poller_thr.daemon = True
                    poller_thr.start()
        except Exception, e:
            if conn: conn.close()
            log(peer, str(type(e)))
            print(format())
            print(e)

    def _setupSocket(self, port):
        s = socket.socket()
        cloexec(s)
        s.settimeout(5)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind(('', port))
        s.listen(10)
        if ssl_mode:
            return ssl.wrap_socket(s,
              keyfile=config['key_file'],
              certfile=config['cert_file'],
              server_side=True)
        return s

    def _bindClient(self):
        port = config['data_port']
        s = self._setupSocket(port)
        log(None, 'Data feed listening on port %d' % port)
        while self.SERVER_ACTIVE:
            if port != config['data_port']:
                newport = config['data_port']
                try:
                    newsock = self._setupSocket(newport)
                    try: s.close()
                    except: pass
                    s = newsock
                    port = newport
                    log(None, 'Data feed listening on port %d' % port)
                    log(None, 'Reloading all clients due to feed port change')
                    self.sendJSON([':R'])
                except IOError, e:
                    log(None, '_setupSocket: %s' % e.args[0])
            try:
                conn, addr = s.accept()
            except Exception, e:
                err = e.args[0]
                if err == 'timed out':
                    continue
                print(format())
                print(e)
                self.SERVER_ACTIVE = False
                return
            peer = '%s:%d' % addr
            log(peer, 'Client connected')
            try:
                cloexec(conn)
                conn.settimeout(5)
                clientType = handshake(conn, peer)
            	self.addClient(conn, addr, clientType)
            except Exception, e:
                conn.close()
                log(peer, str(type(e)))
                print(format())
                print(e)
        log(None, 'Shutting down WS server port: %s' % port)
        return

    def _wsClient(self, client):
        conn = client['conn']
        payload = array.array('B')
        datatype = 0
        while client['alive']:
            try:
                # receive header
                data = conn.recv(2)
                if not data: raise EOFError
                head1, head2 = struct.unpack('!BB', data)
                fin = bool(head1 & 0b10000000)
                isctrl = head1 & 0b00001000
                opcode = head1 & 0b00001111
                length = head2 & 0b01111111
                if length == 126:
                    data = conn.recv(2)
                    if not data: raise EOFError
                    length, = struct.unpack('!H', data)
                elif length == 127:
                    data = conn.recv(8)
                    if not data: raise EOFError
                    length, = struct.unpack('!Q', data)
                mask_bits = conn.recv(4)
                if not mask_bits: raise EOFError
                mask_bits = bytearray(mask_bits)

                # validation
                if not payload and not opcode:
                    raise WSProtocolError('no opcode in initial packet')
                if payload and opcode and not isctrl:
                    raise WSProtocolError('opcode in non-initial packet')
                if isctrl and not fin:
                    raise WSProtocolError('fragmented control packet')
                if not head2 & 0b10000000:
                    raise WSProtocolError('client data not masked')
                if isctrl and length > 125:
                    raise WSProtocolError('control message too long (%d > 125)'
                            % (length))
                if length > maxMessageLen:
                    raise WSProtocolError('packet too long (%d > %d)'
                            % (length, maxMessageLen))
                if length > maxMessageLen - len(payload):
                    raise WSProtocolError('message too long (%d + %d > %d)'
                            % (len(payload), length, maxMessageLen))

                # receive and decode data
                data = conn.recv(length)
                if not data: raise EOFError
                data = bytearray(data)
                DECODED = []
                for i in range(0, len(data)):
                    DECODED.append(data[i] ^ mask_bits[i % 4])

            except socket.timeout:
                continue
            except EOFError:
                log(client['peer'], 'disconnected')
                self._remove(client)
                break
            except IOError, e:
                log(client['peer'], 'recv: %s' % e.args[0])
                self._remove(client)
                break
            except Exception, e:
                log(client['peer'], '%s: %s' % (str(type(e)), e.args[0]))
                print(format())
                print(e)
                self._remove(client)
                break

            if isctrl:
                data = array.array('B', DECODED).tostring()
            else:
                payload.extend(DECODED)
                if opcode: datatype = opcode
                if not fin: continue
                data = payload.tostring()
                del payload[:]

            # handle complete messages
            if opcode == 0x8: # close
                if len(data) >= 2:
                    reason, = struct.unpack('!H', data[0:2])
                    message = data[2:]
                    log(client['peer'], 'connection closed (%d): %s'
                            % (reason,message))
                else:
                    log(client['peer'], 'connection closed')
                self._remove(client)
            elif opcode == 0x9: # ping
                self.sendData(data, opcode=0xa, clients=[client])
            elif opcode == 0xa or (not isctrl and data == "pong"): # pong
                client['last_pong'] = time.time()
                if gui_app: gui_app.update_client_pong(client)
                #log(client['peer'], 'pong')
            elif isctrl:
                log(client['peer'], 'unknown control message %x' % opcode)
            else:
                self.handleData(client, datatype, data)

    def _consClient(self, client):
        conn = client['conn']
        conn.setblocking(True)
        f = conn.makefile('rU')
        while client['alive']:
            try:
                line = f.readline()
                if not line: raise EOFError
                data = line.strip()
                if not data: continue
            except socket.timeout:
                continue
            except EOFError:
                log(client['peer'], 'disconnected')
                self._remove(client)
                break
            except IOError, e:
                log(client['peer'], 'recv: %s' % e.args[0])
                self._remove(client)
                break
            except Exception, e:
                log(client['peer'], '%s: %s' % (str(type(e)), e.args[0]))
                print(format())
                print(e)
                self._remove(client)
                break

            if   data[0] == '+': self.sendMessage(data[1:])
            elif data[0] == '!': self.sendError(data[1:])
            elif data[0] in '{["-0123456789': self.handleData(client, 1, data)
            else:
                self.consoleCommand(client, data.split())

    def _poll(self):
        pingTimeout = wsPingPeriod * wsMaxPings + 3
        try:
            while self.SERVER_ACTIVE:
                #log(None, 'Pinging %d clients' % len(self.clients))
                self.sendData('BigClock', opcode=0x9)
                now = time.time()
                for client in self.clients.values():
                    if client['type'] != 'WS': continue
                    if not client['alive']: continue
                    if now - client['last_pong'] > pingTimeout:
                        log(client['peer'], 'Client timed out')
                        self._remove(client)
                with self.lock:
                    if len(self.clients) == 0:
                        log(None, 'No Clients, shutting down poller')
                        self.POLLER_ACTIVE = False
                        return
                if self.WATCHDOG_ACTIVE:
                    if now - self.last_watchdog > watchdogTimeout:
                        self.watchdog_reset()
                    else:
                        time.sleep(wsPingPeriod)
                else:
                    while time.time() < now + wsPingPeriod:
                        self.sendJSON([])
                        time.sleep(1)
        except Exception, e:
            self.POLLER_ACTIVE = False
            print(format())
            print(e)

    def watchdog_disable(self):
        self.WATCHDOG_ACTIVE = False

    def watchdog_update(self):
        self.WATCHDOG_ACTIVE = True
        self.last_watchdog = time.time()

    def watchdog_reset(self):
        log(None, 'Watchdog reset - restarting relay thread')
        self.WATCHDOG_ACTIVE = False
        restart_relay()

    def startServer(self):
        ws_server_thr = threading.Thread(target=self._bindClient)
        ws_server_thr.name = 'WS Listener'
        ws_server_thr.daemon = True
        ws_server_thr.start()

    def sendData(self, data, fin=True, opcode=1, masking_key=False,
            clients=None, allClients=False, fields=None):
        if fin > 0x1:
            raise ValueError('FIN bit parameter must be 0 or 1')
        if 0x3 <= opcode <= 0x7 or 0xB <= opcode:
            raise ValueError('Opcode cannot be a reserved opcode')

        ## +-+-+-+-+-------++-+-------------+-------------------------------+
        ## |F|R|R|R| opcode||M| Payload len |    Extended payload length    |
        ## |I|S|S|S|  (4)  ||A|     (7)     |             (16/63)           |
        ## |N|V|V|V|       ||S|             |   (if payload len==126/127)   |
        ## | |1|2|3|       ||K|             |                               |
        ## +-+-+-+-+-------++-+-------------+ - - - - - - - - - - - - - - - +
        ## +-+-+-+-+--------------------------------------------------------+
        ## |     Extended payload length continued, if payload len == 127   |
        ## + - - - - - - - - - - - - - - - +--------------------------------+
        ## + - - - - - - - - - - - - - - - +-------------------------------+
        ## |                               |Masking-key, if MASK set to 1  |
        ## +-------------------------------+-------------------------------+
        ## | Masking-key (continued)       |          Payload Data         |
        ## +-------------------------------- - - - - - - - - - - - - - - - +
        ## :                     Payload Data continued ...                :
        ## + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
        ## |                     Payload Data continued ...                |
        ## +---------------------------------------------------------------+
        try:
            header = struct.pack('!B', ((fin << 7)
                                        | (0 << 6)
                                        | (0 << 5)
                                        | (0 << 4)
                                        | opcode))
            if masking_key:
                mask_bit = 1 << 7
            else:
                mask_bit = 0

            length = len(data)
            if length < 126:
                header += struct.pack('!B', (mask_bit | length))
            elif length < (1 << 16):
                header += struct.pack('!B', (mask_bit | 126)) + struct.pack('!H', length)
            elif length < (1 << 63):
                header += struct.pack('!B', (mask_bit | 127)) + struct.pack('!Q', length)

            body = data
            if clients == None:
                with self.lock: clients = self.clients.values()
                if not allClients:
                    clients = [c for c in clients if not c['squelch']]
            for client in clients:
                try:
                    if client['type'] == 'WS':
                        client['conn'].send(bytes(header + body))
                    elif client['type'] in { 'CONSOLE', 'MONITOR'}:
                        client['conn'].send(bytes(body + '\r\n'))
                    elif client['type'] == 'RMON' and fields:
                        client['conn'].send(bytes(','.join(fields) + '\r\n'))
                except IOError, e:
                    log(client['peer'], 'send: %s' % e.args[0])
                    self._remove(client)
        except Exception, e:
            print(format())
            print(e)

    def sendJSON(self, fields, clients=None, allClients=False):
        self.sendData(json.dumps(fields), fields=fields,
                clients=clients, allClients=allClients)

    def sendMessage(self, message):
        fields = [':M', message]
        self.new_client_data[fields[0]] = fields
        self.sendJSON(fields, allClients=True)

    def sendError(self, message):
        fields = [':E', message]
        self.new_client_data[fields[0]] = fields
        self.sendJSON(fields, allClients=True)

    def _remove(self, client):
        self.clients.pop(client['id'], None)
        if gui_app: gui_app.remove_client(client)
        try:
            client['alive'] = False
            client['conn'].close()
        except Exception, e:
            print(e)
            print(format())

    def close(self):
        self.SERVER_ACTIVE = False
        for client in self.clients.values():
            self._remove(client)

    def handleData(self, client, opcode, data):
        if opcode != 1:
            log(client['peer'], 'unsupported message opcode %d' % opcode)
            return
        try:
            fields = json.loads(data)
        except Exception, e:
            log(client['peer'], str(type(e)))
            return
        if fields[0] == '%O':
            client['options'] = fields[1]
            log(client['peer'], 'Options: %s' % fields[1])
        elif fields[0] == '%U':
            client['user_agent'] = fields[1]
            log(client['peer'], 'User-Agent: %s' % fields[1])
        elif fields[0] == '%V':
            client['version_html'] = fields[1]
            client['version_css' ] = fields[2]
            client['version_js'  ] = fields[3]
            log(client['peer'], 'Version: HTML %s / CSS %s / JS %s' % (
                fields[1], fields[2], fields[3]))
        else:
            log(client['peer'], 'unsupported message type %s' % fields[0])

    def _findClient(self, spec):
        n_match = 0
        match = None
        for c in self.clients.values():
            if spec == "%x" % c['id']: return c
            if spec == c['peer']:      return c
            if spec == c['address']:   match = c; n_match += 1
            if spec == c['name']:      match = c; n_match += 1
        if n_match > 1: match = None
        return match

    def refreshClients(self, clients=None):
        self.sendJSON([':V', server_version], clients=clients)
        for item in sorted(self.new_client_data.items()):
            self.sendJSON(item[1], clients=clients)

    def consoleCommand(self, client, fields):
        def reply(data, nl=True):
            if not data: data = ''
            elif nl: data += "\n"
            self.sendData(data, clients=[client])

        log(client['peer'], 'console command %s' % (fields))
        if fields[0] == "version":
            reply("BigClock server v%s" % (server_version))

        elif fields[0] == "config":
            if len(fields) == 1:   # print config
                for opt in sorted(filter(
                    lambda x: x not in config_hide, config.keys())):
                    reply("%-15s %s" % (opt, config[opt]), nl=False)
                reply(None)
            elif len(fields) == 2: # print one config item
                if fields[1] in config_hide:
                    reply("unknown config option %s" % fields[1])
                elif fields[1] in config:
                    reply(str(config[fields[1]]))
                else:
                    reply("unknown config option %s" % fields[1])
            else:
                if fields[1] in config_hide:
                    reply("unknown config option %s" % fields[1])
                elif fields[1] in config_int:
                    try:
                        config[fields[1]] = int(fields[2])
                    except ValueError:
                        reply("invalid value %s" % fields[2])
                elif fields[1] in config:
                    config[fields[1]] = fields[2]
                else:
                    reply("unknown config option %s" % fields[1])

        elif fields[0] == "options":
            if len(fields) < 2:
                reply("options requires a client")
                return
            if len(fields) < 3:
                reply("options required")
                return
            c = self._findClient(fields[1])
            if not c:
                reply("unknown client %s" % spec)
                return
            reply("changing client %x options" % c['id'])
            self.sendJSON([':OPT', fields[2]], clients=[c])

        elif fields[0] == "name":
            if len(fields) < 2:
                reply("name requires a client and new name")
                return
            if len(fields) < 3:
                reply("name requires a new client name")
                return
            c = self._findClient(fields[1])
            if not c:
                reply("unknown client %s" % spec)
                return
            reply("naming %x as %s" % (c['id'],fields[2]))
            c['name'] = fields[2]
            if gui_app: gui_app.update_client_name(c)

        elif fields[0] == "kick":
            if len(fields) < 2:
                reply("kick requires a client")
                return
            for spec in fields[1:]:
                c = self._findClient(spec)
                if not c:
                    reply("unknown client %s" % spec)
                    continue
                reply("kicking %x" % c['id'])
                log(c['peer'], "disconnected via console %s" % client['peer'])
                self._remove(c)

        elif fields[0] == "refresh":
            if len(fields) >= 2:
                cc = filter(None, [ self._findClient(c) for c in fields[1:] ])
                clist = ','.join(['%x' % c['id'] for c in cc])
                reply('Refreshing %s' % clist)
            else:
                cc = None
                reply('Refreshing all clients')
            self.refreshClients()

        elif fields[0] == "reload":
            if len(fields) >= 2:
                cc = filter(None, [ self._findClient(c) for c in fields[1:] ])
                clist = ','.join(['%x' % c['id'] for c in cc])
                reply('Reloading %s' % clist)
            else:
                cc = None
                reply('Reloading all clients')
            self.sendJSON([':R'], clients=cc)

        elif fields[0] == "reconnect":
            reply('restarting rmonitor relay')
            restart_relay()

        elif fields[0] == "restart":
            reply('restarting server')
            restart_server()

        elif fields[0] == "shutdown":
            reply('shutting down server')
            shutdown_server()

        elif fields[0] == "squelch":
            client['squelch'] = True
            if gui_app: gui_app.update_client_sql(client)

        elif fields[0] == "unsquelch":
            client['squelch'] = False
            if gui_app: gui_app.update_client_sql(client)

        elif fields[0] == "clients":
            msg =  "      Client ID  Type     LastSeen  IP Address : Port      Name\n"
            msg += "   ============  =======  ========  =====================  ===============\n"
            for c in self.clients.values():
                fl = '>' if c is client else '-' if not c['alive'] else ' '
                fl += 'S' if c['squelch'] else ' '
                ts = time.strftime('%H:%M:%S', time.localtime(c['last_pong']))
                msg += "%s %12x  %-7s  %-8s  %-21s  %s\n" % (
                        fl, c['id'], c['type'], ts, c['peer'], c['name'])
                if len(fields) > 1 and fields[1] == '-v' and c['type'] == 'WS':
                    msg += "   %s\n   HTML %s / CSS %s / JS %s\n   %s\n\n" % (
                            c['user_agent'], c['version_html'],
                            c['version_css'], c['version_js'], c['options'])
            reply(msg, nl=False)

        elif fields[0] == "threads":
            current = threading.current_thread()
            msg =  "      Thread ID  Description\n"
            msg += "   ============  ===============\n"
            for t in threading.enumerate():
                fl =  '>' if t is current else ' '
                fl += 'D' if t.daemon else ' '
                msg += "%s %12x  %s\n" % (fl, t.ident, t.name)
            reply(msg, nl=False)

        elif fields[0] == "quit":
            self._remove(client)

        elif fields[0] == "help":
            reply(nl=False, data="""
The following commands are available
  config [key [value]]   show or change server config settings
  options client opts    change client config options
  name client nmae       change client name
  kick client...         disconnect a client
  refresh [client...]    resend cached data to one or all clients
  reload [client...]     tell one or all clients to reload page
  reconnect              reconnect to rmonitor feed
  restart                restart server
  shutdown               shut down server
  squelch                disable monitor output
  unsquelch              enable monitor output
  clients [-v]           list connected clients
  threads                list active threads
  help                   show this help message
  version                show server version
  quit                   Disconnect console
  +<msg>                 set status message to <msg>
  !<msg>                 set error message to <msg>
  ... or any JSON object/array/string, as if sent by a client
""")
        else:
            reply('Unrecognized command %s' % fields[0])

class RMonitorPushServer(TCPAcceptServer):
    def __init__(self, relay):
        TCPAcceptServer.__init__(self, 'rmon_port', 'RMON-PUSH')
        self.relay = relay

    def handleClient(self, conn, addr):
        # Kill existing relay thread, if one exists
        if self.relay.RELAY_ACTIVE:
            self.relay.kill()
            self.relay._wait()

        # Start a new relay thread
        server_thread = threading.Thread(
                target=self.relay._run_once, args=(conn,))
        server_thread.name = 'RMonitor Relay'
        server_thread.daemon = True
        server_thread.start()

class RMonitorRelay(object):
    def __init__(self,ws):
        self.ws = ws
        self.server = None
        self.socket = None
        self.rmon_file = None
        self.RELAY_ACTIVE = False
        self.SHUTDOWN = False
        self.shutdown_complete = threading.Event()
        self.close_lock = threading.Lock()

    def _close(self):
        with self.close_lock:
            if self.rmon_file:
                try:
                    self.rmon_file.close()
                except:
                    pass
                finally:
                    self.rmon_file = None
            if self.socket:
                try:
                    self.socket.shutdown(socket.SHUT_RDWR)
                    self.socket.close()
                except:
                    pass
                finally:
                    self.socket = None

    def _connect(self):
        self.ws.watchdog_disable()
        self.RELAY_ACTIVE = True
        server = (config['rmon_server'], config['rmon_port'])
        log(None, 'Connecting to RMonitor feed at %s:%d' % server)
        try:
            self.socket = socket.create_connection(server, 5)
        except:
            self._close()
            raise

    def _relay(self, watchdog=True):
        error_cleared = False
        try:
            cloexec(self.socket)
            self.socket.setblocking(True)
            self.rmon_file = self.socket.makefile("rb")
            rmon_csv = csv.reader(self.rmon_file)
        except:
            self._close()
            raise

        try:
            log(None, 'RMonitor feed connected')
            if watchdog: self.ws.watchdog_update()
            if gui_app: gui_app.relay_state(True)

            while self.RELAY_ACTIVE:
                try: fields = rmon_csv.next()
                except StopIteration: break
                if not fields:
                    break
                fields = [ codecs.decode(x, 'cp1252') for x in fields ]
                jd = json.dumps(fields)
                if gui_app: gui_app.report(jd)
                #else: sys.stdout.write(jd + '\n')
                # Update the cache before sending the data.  This insures that
                # any new client will see this data, because new clients are
                # sent the entire cache before being added to the send list,
                # and locking prevents any all-clients sends in between.
                if   fields[0] == '$I':
                    self.ws.new_client_data.clear()
                    self.ws.new_client_data[''] = fields
                elif fields[0] in {'$A' }:
                    self.ws.new_client_data[ '%s%s' % (fields[0], fields[1]) ] = fields
                elif fields[0] in {'$C','$G'}:
                    self.ws.new_client_data[ '%s%3d' % (fields[0], int(fields[1])) ] = fields
                elif fields[0] in {'$B'}:
                    self.ws.new_client_data[fields[0]] = fields
                if watchdog: self.ws.watchdog_update()
                self.ws.sendJSON(fields)
                if not error_cleared:
                    self.ws.sendError('')
                    error_cleared = True
        finally:
            self.ws.watchdog_disable()
            self._close()
            log(None, 'RMonitor relay disconnected')
            ws.sendError('Lost rmonitor feed')
            if gui_app: gui_app.relay_state(False)

    def _run_loop(self):
        try:
            while not self.SHUTDOWN:
                try:
                    self._connect()
                    self._relay()
                except socket.error as e:
                    # ignore socket errors if we're shutting down
                    if self.RELAY_ACTIVE:
                        log(None, str(e))
                        ws.sendError('Lost rmonitor feed')
                if self.RELAY_ACTIVE and not self.SHUTDOWN:
                    time.sleep(5)
        finally:
            log(None, 'RMonitor relay shut down')
            self.shutdown_complete.set()

    def _run_once(self, s):
        self.ws.watchdog_disable()
        self.RELAY_ACTIVE = True
        self.socket = s

        try:
            self._relay(watchdog=False)
        except socket.error as e:
            # ignore socket errors if we're shutting down
            if self.RELAY_ACTIVE:
                log(None, str(e))
                ws.sendError('Lost rmonitor feed')
        finally:
            self.RELAY_ACTIVE = False
            self.shutdown_complete.set()

    def start(self):
        if config['rmon_server'] == '-':
            self.server = RMonitorPushServer(self)
            self.server.startServer()
        else:
            server_thread = threading.Thread(target=self._run_loop)
            server_thread.name = 'RMonitor Relay'
            server_thread.daemon = True
            server_thread.start()

    def kill(self):
        self.RELAY_ACTIVE = False
        self._close()

    def _wait(self):
        try:
            while not self.shutdown_complete.wait(0.5): pass
        except KeyboardInterrupt:
            pass

    def wait(self):
        if self.server:
            self.server.wait()
        else:
            self._wait()

    def shutdown(self):
        if self.server: self.server.close()
        self.SHUTDOWN = True
        self.kill()


FILL_PARENT = tk.N+tk.S+tk.E+tk.W

class ScrolledLogFrame(ScrolledText.ScrolledText):
    def __init__(self, master, maxLines=None, **kwargs):
        kw = { 'insertofftime' : 0, 'width' : 80 }
        kw.update(kwargs)
        ScrolledText.ScrolledText.__init__(self, master, **kw)
        self.redirector = WidgetRedirector(self)
        self.insert = self.redirector.register('insert',
                lambda *args, **kw: "break")
        self.delete = self.redirector.register('delete',
                lambda *args, **kw: "break")
        self.replace = self.redirector.register('replace',
                lambda *args, **kw: "break")
        self.bind('<1>', lambda event: self.focus_set())
        self.maxLines = maxLines
        self.queue = Queue.Queue()
        self.after(100, self.process_queue)
        self.empty = True

    def process_queue(self):
        try:
            while True:
                msg = self.queue.get_nowait()
                (a,b) = self.vbar.get()
                if self.empty:
                    self.empty = False
                else:
                    self.insert(tk.END, '\n')
                self.insert(tk.END, msg)
                if self.maxLines:
                    self.delete('1.0', 'end linestart - %d lines' % self.maxLines)
                if b >= 1.0: self.see(tk.END)
        except Queue.Empty:
            pass
        finally:
            self.after(100, self.process_queue)

    def appendMsg(self, msg):
        self.queue.put(msg)

    def clear(self):
        self.delete('1.0', tk.END)
        self.empty = True

class BigClockClient(object):
    def __init__(self, master, client):
        self.client = client
        self.sql_v  = tk.BooleanVar()
        self.pong_v = tk.StringVar()
        self.name_v = tk.StringVar()
        self.set_pong(client['last_pong'])
        if client['name']: self.set_name(client['name'])

        self.sql_btn = tk.Checkbutton(master, onvalue=True, offvalue=False,
                anchor=tk.CENTER, borderwidth=0, bg='white', highlightbackground='white',
                variable=self.sql_v, command=self.squelch_pushed)
        self.cid  = tk.Label(master, bg='white', anchor=tk.W, width=10, text='%x' % client['id'])
        self.type = tk.Label(master, bg='white', anchor=tk.W, width= 8, text=client['type'])
        self.pong = tk.Label(master, bg='white', anchor=tk.W, width= 8, textvariable=self.pong_v)
        self.name = tk.Label(master, bg='white', anchor=tk.W, width=15, textvariable=self.name_v)
        self.peer = tk.Label(master, bg='white', anchor=tk.W, width=15, text=client['peer'])
        self.actions = tk.Frame(master, bg='white')
        self.push_btn   = tk.Button(self.actions, text='Push', command=self.push)
        self.reload_btn = tk.Button(self.actions, text='Reload', command=self.reload)
        self.kick_btn   = tk.Button(self.actions, text='Kick', command=self.kick)
        self.push_btn.grid  (row=0, column=0)
        self.reload_btn.grid(row=0, column=1)
        self.kick_btn.grid  (row=0, column=2)

    def destroy(self):
        self.sql_btn.grid_forget(); self.sql_btn.destroy()
        self.cid.grid_forget();     self.cid.destroy()
        self.type.grid_forget();    self.type.destroy()
        self.pong.grid_forget();    self.pong.destroy()
        self.name.grid_forget();    self.name.destroy()
        self.peer.grid_forget();    self.peer.destroy()
        self.actions.grid_forget(); self.actions.destroy()

    def regrid(self,row):
        self.row = row
        self.sql_btn.grid(row=row, column=0, padx=1, sticky=FILL_PARENT)
        self.cid.grid    (row=row, column=1, padx=1, sticky=tk.N+tk.S+tk.W)
        self.type.grid   (row=row, column=2, padx=1, sticky=tk.N+tk.S+tk.W)
        self.pong.grid   (row=row, column=3, padx=1, sticky=tk.N+tk.S+tk.W)
        self.name.grid   (row=row, column=4, padx=1, sticky=tk.N+tk.S+tk.W)
        self.peer.grid   (row=row, column=5, padx=1, sticky=tk.N+tk.S+tk.W)
        self.actions.grid(row=row, column=6, padx=1, sticky=tk.N+tk.S+tk.W+tk.E)

    def push(self):
        log(None, 'refreshing %x' % self.client['id'])
        ws.refreshClients(clients=[self.client])

    def reload(self):
        log(None, 'reloading %x' % self.client['id'])
        ws.sendJSON([':R'], clients=[self.client])

    def kick(self):
        log(None, 'disconnecting %x' % self.client['id'])
        ws._remove(self.client)

    def squelch_pushed(self): self.client['squelch'] = self.sql_v.get()
    def set_squelch(self,state): self.sql_v.set(state)
    def set_name(self,name): self.name_v.set(name)
    def set_pong(self,when): self.pong_v.set(time.strftime('%H:%M:%S', time.localtime(when)))

class BigClockClientList(tk.Frame):
    def __init__(self, master):
        self.clients = {}
        self.n_clients = 0
        tk.Frame.__init__(self, master)
        self.columnconfigure(0, weight=1)
        self.rowconfigure(1, weight=1)

        # Framework
        self.header_frame = hf = tk.Frame(self, bg='black')
        self.canvas = tk.Canvas(self)
        self.canvas.columnconfigure(0, weight=1)
        self.canvas.rowconfigure(1, weight=1)
        self._makeRows()
        self.empty_space = tk.Canvas(self.canvas, bg='white', borderwidth=0)
        self.scrollbar = tk.Scrollbar(self, orient=tk.VERTICAL)
        self.canvas['yscrollcommand'] = self.scrollbar.set
        self.scrollbar['command'] = self.canvas.yview
        self.header_frame.grid(row=0, column=0, ipady=1, sticky=tk.W+tk.E)
        self.canvas.grid(row=1, column=0, sticky=FILL_PARENT)
        self.scrollbar.grid(row=1, column=1, sticky=tk.N+tk.S)
        self.empty_space.grid(row=1, column=0, sticky=FILL_PARENT)

        # Column Headers and Widths
        bgcol = '#d9d9d9'
        self.header_frame.columnconfigure(0, minsize=35)
        self.header_frame.columnconfigure(6, minsize=200, weight=1)
        self.sql_header  = tk.Label(hf, anchor=tk.CENTER, bg=bgcol, text='Sql')
        self.cid_header  = tk.Label(hf, anchor=tk.W, bg=bgcol, width=10, text='Client ID')
        self.type_header = tk.Label(hf, anchor=tk.W, bg=bgcol, width= 8, text='Type')
        self.pong_header = tk.Label(hf, anchor=tk.W, bg=bgcol, width= 8, text='Last Seen')
        self.name_header = tk.Label(hf, anchor=tk.W, bg=bgcol, width=15, text='Name')
        self.peer_header = tk.Label(hf, anchor=tk.W, bg=bgcol, width=15, text='IP Address:Port')
        self.act_header  = tk.Label(hf, anchor=tk.W, bg=bgcol, width=25, text='Actions')

        self.sql_header.grid (row=0, column=0, padx=1, sticky=FILL_PARENT)
        self.cid_header.grid (row=0, column=1, padx=1, sticky=tk.W)
        self.type_header.grid(row=0, column=2, padx=1, sticky=tk.W)
        self.pong_header.grid(row=0, column=3, padx=1, sticky=tk.W)
        self.name_header.grid(row=0, column=4, padx=1, sticky=tk.W)
        self.peer_header.grid(row=0, column=5, padx=1, sticky=tk.W)
        self.act_header.grid (row=0, column=6, padx=1, sticky=tk.W+tk.E)

        self.queue = Queue.Queue()
        self.after(100, self.process_queue)

    def _makeRows(self):
        if getattr(self, 'rows', None):
            self.rows.grid_forget()
            self.rows.destroy()
        self.rows = tk.Frame(self.canvas, bg='black', borderwidth=0)
        self.rows.columnconfigure(0, minsize=35)
        self.rows.columnconfigure(6, minsize=200, weight=1)
        self.rows.grid(row=0, column=0, sticky=tk.N+tk.W+tk.E)

    def regrid_clients(self,key=lambda x: x.row):
        clients = sorted(self.clients.values(), key=key)
        row = 0
        for c in clients:
            c.regrid(row)
            row += 1

    def process_queue(self):
        try:
            while True:
                (op, client) = self.queue.get_nowait()
                if op == 'add':
                    self.clients[client['id']] = c = BigClockClient(self.rows, client)
                    c.regrid(self.n_clients)
                    self.n_clients += 1
                elif op == 'del':
                    c = self.clients.pop(client['id'], None)
                    if c: c.destroy()
                    self.n_clients = len(self.clients)
                    if self.n_clients: self.regrid_clients()
                    else: self._makeRows()
                else:
                    c = self.clients.get(client['id'])
                    if not c: continue
                    elif op == 'sql': c.set_squelch(client['squelch'])
                    elif op == 'nam': c.set_name(client['name'])
                    elif op == 'ack': c.set_pong(client['last_pong'])
        except Queue.Empty:
            pass
        finally:
            self.after(100, self.process_queue)

class BigClockGUI(tk.Frame):
    def __init__(self, master=None):
        global config
        tk.Frame.__init__(self, master)
        config = TkConfigVars(config, intkeys=config_int)
        self.winfo_toplevel().rowconfigure(0, weight=1)
        self.winfo_toplevel().columnconfigure(0, weight=1)
        self.grid(sticky=FILL_PARENT)
        self.createWidgets()

    def show_hide_panes(self):
        panes = set([self.panewin.nametowidget(str(tcl_obj))
            for tcl_obj in self.panewin.panes()])
        for i in range(len(self.panes)):
            vis  = self.pane_vis[i].get()
            pane = self.panes[i]
            if not vis and pane in panes:
                self.panewin.remove(pane)
                panes.remove(pane)
            if vis and pane not in panes:
                for j in range(i+1, len(self.panes)):
                    if self.panes[j] in panes:
                        self.panewin.add(pane, before=self.panes[j])
                        panes.add(pane)
                        break
                if pane not in panes:
                    self.panewin.add(pane)
                    panes.add(pane)

    def createWidgets(self):
        self.config_frame = cf = tk.Frame(self)
        self.config_frame.rowconfigure(0, minsize=27)
        self.config_frame.rowconfigure(1, minsize=27)
        self.config_frame.rowconfigure(2, minsize=27)
        self.config_frame.columnconfigure(6, weight=1)

        # Configuration Labels
        self.rmon_state  = tk.Label(cf, anchor=tk.W, text="Connecting...", fg="red")
        self.data_label  = tk.Label(cf, anchor=tk.W, text="Data Feed Port:")
        self.mon_label   = tk.Label(cf, anchor=tk.W, text="Monitor Port:")
        self.cons_label  = tk.Label(cf, anchor=tk.W, text="Console Port:")
        self.http_label  = tk.Label(cf, anchor=tk.W, text="Web Server Port:")
        self.https_label = tk.Label(cf, anchor=tk.W, text="SSL Web Port:")
        self.tz_label    = tk.Label(cf, anchor=tk.W, text="Time Zone:")

        # Configuration Data Fields
        self.rmon_port   = tk.Entry(cf, width=6, textvariable=config.var('rmon_port'))
        self.http_entry  = tk.Entry(cf, width=6, textvariable=config.var('http_port'))
        self.https_entry = tk.Entry(cf, width=6, textvariable=config.var('https_port'))
        self.data_entry  = tk.Entry(cf, width=6, textvariable=config.var('data_port'))
        self.cons_entry  = tk.Entry(cf, width=6, textvariable=config.var('console_port'))
        self.mon_entry   = tk.Entry(cf, width=6, textvariable=config.var('monitor_port'))
        self.tz_entry    = tk.Entry(cf, textvariable=config.var('timezone'))

        # Reconnect button
        self.reconn_btn = tk.Button(cf, text='Reconnect', command=restart_relay)

        # Special handling for rmonitor:
        if config['rmon_server'] == '-':
            self.rmon_label = tk.Label(cf, anchor=tk.W, text="RMonitor Push Feed Port:")
            self.rmon_label.grid(row=0, column=0, sticky=tk.W, columnspan=3)
        else:
            self.rmon_label = tk.Label(cf, anchor=tk.W, text="RMonitor Feed:")
            self.rmon_label.grid(row=0, column=0, sticky=tk.W)

            self.rmon_entry = tk.Frame(cf)
            self.rmon_sep = tk.Label(self.rmon_entry, text=":")
            self.rmon_host = tk.Entry(self.rmon_entry, width=16,
                    textvariable=config.var('rmon_server'))
            self.rmon_host.grid(row=0, column=0, sticky=tk.W+tk.E)
            self.rmon_sep.grid (row=0, column=1, sticky=tk.E)
            self.rmon_entry.grid(row=0, column=1, sticky=tk.W+tk.E, columnspan=2)

        # Configuration Layout
        self.rmon_port.grid (row=0, column=3, sticky=tk.W)
        self.rmon_state.grid(row=0, column=4, sticky=tk.W, columnspan=2)
        self.data_label.grid(row=1, column=0, sticky=tk.W)
        self.data_entry.grid(row=1, column=1, sticky=tk.W)
        self.mon_label.grid (row=1, column=2, sticky=tk.W)
        self.mon_entry.grid (row=1, column=3, sticky=tk.W)
        self.cons_label.grid(row=1, column=4, sticky=tk.W)
        self.cons_entry.grid(row=1, column=5, sticky=tk.W)
        self.http_label.grid(row=2, column=0, sticky=tk.W)
        self.http_entry.grid(row=2, column=1, sticky=tk.W)
        self.https_label.grid(row=2, column=2, sticky=tk.W)
        self.https_entry.grid(row=2, column=3, sticky=tk.W)
        self.tz_label.grid  (row=2, column=4, sticky=tk.W)
        self.tz_entry.grid  (row=2, column=5, sticky=tk.W, columnspan=3)
        self.reconn_btn.grid(row=0, column=6, sticky=tk.NE)
        self.config_frame.grid(sticky=tk.N+tk.W+tk.E)

        self.columnconfigure(0, weight=1)
        self.rowconfigure(1, weight=1)
        self.panewin = tk.PanedWindow(self, orient=tk.VERTICAL, showhandle=True)
        self.panewin.grid(sticky=FILL_PARENT)

        # Recent Data
        self.data_frame = tk.LabelFrame(self, text='Recent Data')
        self.data_frame.rowconfigure(0, weight=1)
        self.data_frame.columnconfigure(0, weight=1)
        self.data_log = ScrolledLogFrame(self.data_frame, height=5, maxLines=60)
        self.data_log.grid(sticky=FILL_PARENT)

        self.data_buttons = tk.Frame(self.data_frame)
        self.data_buttons.columnconfigure(2, weight=1)
        self.refresh_btn = tk.Button(self.data_buttons, text='Send Refresh',
                command=self.refresh_clients)
        self.cache_btn = tk.Button(self.data_buttons, text='View Cache') #XXX
        self.clear_data_btn = tk.Button(self.data_buttons, text='Clear Data',
                command=self.data_log.clear)
        self.refresh_btn.grid   (row=0, column=0)
        self.cache_btn.grid     (row=0, column=1)
        self.clear_data_btn.grid(row=0, column=2, sticky=tk.E)
        self.data_buttons.grid(row=1, column=0, sticky=tk.S+tk.W+tk.E)

        self.panewin.add(self.data_frame, sticky=FILL_PARENT)

        # Clients
        self.client_frame = tk.LabelFrame(self, text='Active Clients')
        self.client_frame.rowconfigure(0, weight=1)
        self.client_frame.columnconfigure(0, weight=1)
        self.client_list = BigClockClientList(self.client_frame)
        self.client_list.grid(sticky=FILL_PARENT)
        self.panewin.add(self.client_frame, sticky=FILL_PARENT)

        # Log Messages
        self.msg_frame = tk.LabelFrame(self, text='System Messages')
        self.msg_frame.rowconfigure(0, weight=1)
        self.msg_frame.columnconfigure(0, weight=1)
        self.msg_log = ScrolledLogFrame(self.msg_frame, height=10, maxLines=1000)
        self.msg_log.grid(sticky=FILL_PARENT)
        self.clear_msg_btn = tk.Button(self.msg_frame, text='Clear Log',
                command=self.msg_log.clear)
        self.clear_msg_btn.grid(row=1, column=0, sticky=tk.E)
        self.panewin.add(self.msg_frame, sticky=FILL_PARENT)

        # Menu Bar
        self.menubar = tk.Menu(self)
        self.master.config(menu=self.menubar)

        menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="File", menu=menu)
        menu.add_command(label="Restart", command=restart_server)
        menu.add_command(label="Quit", command=self.quit)

        menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="View", menu=menu)
        self.panes = [self.panewin.nametowidget(str(tcl_obj))
                for tcl_obj in self.panewin.panes()]
        self.pane_vis = []
        for i in range(len(self.panes)):
            self.pane_vis.append(tk.BooleanVar())
            self.pane_vis[i].set(True)
            menu.add_checkbutton(label=self.panes[i]['text'],
                    variable=self.pane_vis[i], onvalue=True, offvalue=False,
                    command=self.show_hide_panes)

    def refresh_clients(self):
        ws.refreshClients()

    def relay_state(self,state):
        if state:
            self.rmon_state['text'] = "Connected"
            self.rmon_state['fg']   = "green"
        else:
            self.rmon_state['text'] = "Connection Lost"
            self.rmon_state['fg']   = "red"

    def add_client(self,client):         self.client_list.queue.put(('add', client))
    def remove_client(self,client):      self.client_list.queue.put(('del', client))
    def update_client_pong(self,client): self.client_list.queue.put(('ack', client))
    def update_client_name(self,client): self.client_list.queue.put(('nam', client))
    def update_client_sql(self,client):  self.client_list.queue.put(('sql', client))

    def log(self,msg):
        self.msg_log.appendMsg(msg)

    def report(self,msg):
        self.data_log.appendMsg(msg)

def shutdown_server():
    if gui_app: gui_app.quit()
    else: rmon_relay.shutdown()

def restart_server():
    global ReExec
    ReExec = True
    shutdown_server()

def restart_relay():
    rmon_relay.kill()

if __name__ == '__main__':
    # Find the main program and change to its directory
    if hasattr(sys, "frozen"):
        mainprog = sys.executable
    else:
        mainprog = sys.argv[0]
    progdir = os.path.dirname(mainprog)
    if progdir:
        os.chdir(os.path.dirname(mainprog))

    # Compute and report server version
    try:
        ts = os.stat(mainprog).st_mtime
        server_version += time.strftime('-%y%m%d-%H%M%S', time.localtime(ts))
    except Exception:
        pass

    parse_args()

    if config['gui']:
        if hasattr(sys, "frozen") and sys.frozen == "windows_exe":
            # py2exe helpfully discards stdout for us on Windows
            # If running in GUI mode, discard stderr as well.
            sys.stderr = sys.stdout
        gui_app = BigClockGUI()
        gui_app.master.title('BigClock v%s' % server_version)

    log(None, "BigClock server v%s" % (server_version))

    # Start WebSocket and HTTP servers
    ws = WebSocketServer()
    console_acceptor = TCPUserServer('console_port', 'CONSOLE', ws)
    monitor_acceptor = TCPUserServer('monitor_port', 'MONITOR', ws)
    rmrelay_acceptor = TCPUserServer('rmrelay_port', 'RMON', ws)
    rmon_relay = RMonitorRelay(ws)

    httpd = MyHTTPServer(('', config['http_port']), MyHTTPRequestHandler)
    httpd_thr = threading.Thread(target=httpd.serve_forever)
    httpd_thr.name = 'HTTP Listener'
    httpd_thr.daemon = True

    if ssl_mode:
        httpsd = MyHTTPServer(('', config['https_port']), MyHTTPRequestHandler)
        httpsd.socket = ssl.wrap_socket(httpsd.socket,
          keyfile=config['key_file'],
          certfile=config['cert_file'],
          server_side=True)
        httpsd_thr = threading.Thread(target=httpsd.serve_forever)
        httpsd_thr.name = 'HTTP SSL Listener'
        httpsd_thr.daemon = True

    def start_servers():
        global addrmapper
        addrmapper = AddressMapper(ws)
        ws.startServer()
        console_acceptor.startServer()
        monitor_acceptor.startServer()
        rmrelay_acceptor.startServer()
        rmon_relay.start()
        httpd_thr.start()
        if ssl_mode: httpsd_thr.start()

    if config['gui']:
        gui_app.master.after_idle(start_servers)
        gui_app.mainloop()
        rmon_relay.shutdown()
    else:
        start_servers()
        rmon_relay.wait()

    httpd.shutdown()
    if ssl_mode: httpsd.shutdown()
    console_acceptor.close()
    monitor_acceptor.close()
    rmrelay_acceptor.close()
    ws.close()
    if ReExec:
        if sys.argv[0] == '' or sys.argv[0] == '-c':
            log(None, "Unable to reexec from non-file")
        else:
            if sys.executable:
                args = sys.argv
                args.insert(0, 'python')
                os.execv(sys.executable, args)
            else:
                os.execv(sys.argv[0], sys.argv)
